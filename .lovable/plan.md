
# Plan: Frontend Security Hardening

## Overview

This plan addresses frontend security concerns to make it harder for users to inspect API calls, copy source code, and remove any development-related artifacts before production deployment.

---

## Key Findings from Exploration

| Area | Current State | Risk |
|------|--------------|------|
| **Source Maps** | Generated by default in Vite | **HIGH** - Full source code visible in browser DevTools |
| **Console Logs** | 300+ console.log/error statements across 26 files | **MEDIUM** - Leaks internal debugging info |
| **API URLs Visible** | Edge function URLs visible in network tab | **LOW** - Expected, but can obfuscate |
| **Lovable Tagger** | Development-only, already disabled in production | **LOW** - No action needed |
| **Environment Variables** | Using VITE_ prefix (client-side visible) | **LOW** - These are public keys, acceptable |

---

## What CAN Be Secured (Practical Improvements)

### 1. Disable Source Maps in Production

**Problem:** Source maps allow anyone to view your original TypeScript/React code in browser DevTools.

**Solution:** Configure Vite to not generate source maps for production builds.

**File:** `vite.config.ts`

**Changes:**
```typescript
export default defineConfig(({ mode }) => ({
  build: {
    sourcemap: false, // Disable source maps in production
    minify: 'terser', // Use terser for better minification
    terserOptions: {
      compress: {
        drop_console: true, // Remove console.log in production
        drop_debugger: true,
      },
      mangle: true, // Mangle variable names
    },
  },
  // ... existing config
}));
```

### 2. Remove Console Logs in Production

**Problem:** 300+ console statements leak internal application state and debugging information.

**Files Affected:** 26 files with console statements

**Solution:** Configure Terser to automatically strip console.* calls during production build (included in Vite config above).

**Benefits:**
- No manual code changes needed
- Console logs still work during development
- Automatically removed during `npm run build`

### 3. Add Security Headers via index.html Meta Tags

**Problem:** No Content Security Policy or other security headers.

**Solution:** Add security-related meta tags to `index.html`:

```html
<!-- Prevent clickjacking -->
<meta http-equiv="X-Frame-Options" content="DENY" />

<!-- Prevent MIME type sniffing -->
<meta http-equiv="X-Content-Type-Options" content="nosniff" />

<!-- Referrer policy - don't leak URLs -->
<meta name="referrer" content="strict-origin-when-cross-origin" />
```

Note: Full CSP headers should be set at the server/CDN level for proper enforcement.

### 4. Obfuscate Sensitive Error Messages

**Problem:** Error messages sometimes reveal internal structure.

**Solution:** Sanitize user-facing error messages to remove technical details.

**Example Change:**
```typescript
// Before
toast({ description: error.message });

// After  
toast({ description: "Something went wrong. Please try again." });
console.error("Internal error:", error); // Stripped in production
```

### 5. Lovable Tagger - Already Secured

**Current Code (vite.config.ts line 15):**
```typescript
plugins: [react(), mode === "development" && componentTagger()].filter(Boolean)
```

The lovable-tagger is already conditionally loaded only in development mode. No changes needed.

---

## What CANNOT Be Fully Secured (Important to Understand)

### API Endpoints
- Network requests will always be visible in browser DevTools
- **This is expected behavior** - any web app has visible network calls
- **Security comes from backend authentication**, not hiding endpoints
- Our edge functions already require JWT tokens - this is the correct approach

### JavaScript Code
- Even with minification and obfuscation, determined attackers can reverse-engineer
- **True security comes from server-side validation**, which we've already implemented
- The goal is to make casual inspection harder, not impossible

### Environment Variables (VITE_*)
- These are intentionally public (publishable keys)
- Supabase anon key is designed to be public
- Secret keys are stored in backend edge functions (already done correctly)

---

## Implementation Summary

| Task | File | Effort |
|------|------|--------|
| Disable source maps | vite.config.ts | Small |
| Add Terser minification | vite.config.ts | Small |
| Remove console in production | vite.config.ts (Terser config) | Small |
| Add security meta tags | index.html | Small |
| Sanitize error messages | Multiple files | Medium |

---

## Detailed File Changes

### 1. vite.config.ts - Production Build Security

**Current:**
```typescript
export default defineConfig(({ mode }) => ({
  server: { ... },
  plugins: [...],
  resolve: { ... },
}));
```

**New:**
```typescript
export default defineConfig(({ mode }) => ({
  server: { ... },
  plugins: [...],
  resolve: { ... },
  build: {
    sourcemap: false,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
        pure_funcs: ['console.log', 'console.info', 'console.debug'],
      },
      mangle: {
        safari10: true,
      },
      format: {
        comments: false,
      },
    },
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          supabase: ['@supabase/supabase-js'],
        },
      },
    },
  },
}));
```

**Why Terser over ESBuild (default)?**
- Terser provides better minification and obfuscation
- Has drop_console feature to automatically remove console statements
- Better mangle options for variable name obfuscation

**Note:** Need to add `terser` as a dev dependency.

### 2. index.html - Security Meta Tags

Add these meta tags in the `<head>`:

```html
<!-- Security Headers -->
<meta http-equiv="X-Frame-Options" content="DENY" />
<meta http-equiv="X-Content-Type-Options" content="nosniff" />
<meta name="referrer" content="strict-origin-when-cross-origin" />
```

### 3. package.json - Add Terser Dependency

```json
"devDependencies": {
  "terser": "^5.31.0",
  // ... existing deps
}
```

---

## Additional Recommendations (Optional)

### Rate Limiting (Recommended for Production)

Consider implementing client-side rate limiting for sensitive operations:

```typescript
// Utility for rate limiting
const rateLimitMap = new Map<string, number>();

function isRateLimited(action: string, limitMs: number = 1000): boolean {
  const lastCall = rateLimitMap.get(action);
  const now = Date.now();
  if (lastCall && now - lastCall < limitMs) {
    return true;
  }
  rateLimitMap.set(action, now);
  return false;
}
```

### Disable React DevTools in Production (Optional)

Add to `src/main.tsx`:

```typescript
if (import.meta.env.PROD) {
  // Disable React DevTools
  if (typeof window.__REACT_DEVTOOLS_GLOBAL_HOOK__ === 'object') {
    for (const [key, value] of Object.entries(window.__REACT_DEVTOOLS_GLOBAL_HOOK__)) {
      window.__REACT_DEVTOOLS_GLOBAL_HOOK__[key] = typeof value === 'function' ? () => {} : null;
    }
  }
}
```

---

## What This Achieves

| Before | After |
|--------|-------|
| Source maps expose all original code | Minified, obfuscated code only |
| Console logs visible to users | Automatically stripped in production |
| No security headers | Basic security meta tags |
| Debug info in errors | Sanitized user-friendly messages |

---

## Security Layers Summary

```text
+------------------------------------------+
|     FRONTEND (This Plan)                 |
|  - Source maps disabled                  |
|  - Code minified & obfuscated            |
|  - Console logs stripped                 |
|  - Security headers added                |
+------------------------------------------+
           |
           v
+------------------------------------------+
|     BACKEND (Already Done)               |
|  - JWT authentication on all endpoints   |
|  - Role-based access (super_admin)       |
|  - Input validation with Zod             |
|  - Rate limiting via Supabase            |
|  - RLS policies on database              |
+------------------------------------------+
```

The frontend changes make casual inspection harder, while the backend changes (already implemented) provide the real security.

---

## Post-Implementation Testing

After implementing these changes:

1. Run `npm run build` and check the `dist` folder
2. Verify no `.map` files are generated
3. Open the production build and check:
   - DevTools Sources tab shows minified code only
   - Console has no application logs
   - Network tab still works (expected)
4. Test all functionality still works correctly

